etcd: mission critical key-value store
Gopherfest
16 May 2016

Gyu-Ho Lee
CoreOS
gyu_ho.lee@coreos.com
https://github.com/coreos/etcd


* Welcome

Slides are here:

.link https://github.com/gyuho/presentations github.com/gyuho/presentations


* Go + etcd

.image img/gopherbw.png _ 200
.image img/etcd-glyph-color.svg _ 200


* Agenda

- What is etcd
- Why
- Go
- Q/A


* What is etcd


* etcd is ...

- Distributed key-value store
- Open source [[https://github.com/coreos/etcd][github.com/coreos/etcd]]
- Since June 2013
- Still new (vs ZooKeeper since May 2008)
- Google, Red Hat, EMC, Cisco, Huawei, Baidu, Alibaba...



* etcd API


    cli.Put(ctx, "foo", "bar", Lease)
    cli.Get(ctx, "foo")
    cli.Delete(ctx, "foo")

    // Transaction
    kvc.Txn(ctx).
     If(clientv3.Compare(clientv3.Value("key"), ">", "abc")). // txn value comparisons are lexical
     Then(clientv3.OpPut("key", "XYZ")).                      // this runs, since 'xyz' > 'abc'
     Else(clientv3.OpPut("key", "ABC")).
     Commit()
    
    // Watch for updates on key
    ch := cli.Watch(ctx, "foo") 
    for res := range ch {}

    // Distributed locks
    mu := concurrency.NewMutex(cli, "foo")
    mu.Lock()
    mu.Unlock()



* Why etcd

* Use etcd to store configuration

* Updates

.image img/coreos_update_uncoordinated_00.png _ 700

How would you update the cluster of machines?


* Traditional way

.image img/coreos_update_uncoordinated_01.png _ 700

- Reboot with downtime
- Manual


* CoreOS updates with etcd

- CoreOS is an open-source Linux OS
- Automatic, No-downtime updates with etcd

.image img/coreos_update_coordinated_00.png _ 700

Powered by etcd and [[https://github.com/coreos/locksmith][github.com/coreos/locksmith]]


* CoreOS updates with etcd

- locksmith stores semephore values in etcd
- ensure that only a subset of a cluster of machines are rebooting at any given time

.image img/coreos_update_coordinated_01.png _ 700


* CoreOS updates with etcd

- Automatic
- No downtime

.image img/coreos_update_coordinated_02.png _ 700


* CoreOS updates with etcd

.image img/coreos_update_coordinated_03.png _ 700

Your cluster is now secured

* Use etcd for "critical" configuration

* Bad practice

.image img/etcd_store_configuration_bad_00.png _ 700

* Bad practice

.image img/etcd_store_configuration_bad_01.png _ 700

* Good practice

.image img/etcd_store_configuration_good_00.png _ 700


* Good practice

.image img/etcd_store_configuration_good_01.png _ 700


* Demo

.link http://play.etcd.io play.etcd.io

Join me!


* etcd

Consistent view of critical configuration

- Strong consistency (no stale reads)
- Different than eventual consistency (conflicts, latest timestamps wins)

Highly available configuration store

- Resilient to a single point of failures & network partitions

Watchable

- Push configuration updates to application


* Why not ZooKeeper or Consul?


* etcd Project Status


* etcd Performance

* etcd v3

[[https://github.com/boltdb/bolt][BoltDB]]

- B+tree disk storage
- Incremental snapshot
- vs ZooKeeper snapCount 10,000 

[[http://www.grpc.io/][gRPC]]

- Protocol Buffer
- HTTP/2
- streams, less TCP congestions


* Throughput

.image img/etcd_vs_others_throughput.svg _ 900

* Latency

.image img/etcd_vs_others_latency.svg _ 900

* CPU

.image img/etcd_vs_others_cpu.svg _ 900

* Memory

.image img/etcd_vs_others_memory.svg _ 900


* etcd Reliability

* Throughput

.image img/etcd_vs_zk_throughput.svg _ 900

* etcd Reliability

.image img/etcd_vs_zk_throughput_comment.png 350 950

ZooKeeper logs

    07:16:35 [Snapshot Thread:FileTxnSnapLog@240] - Snapshotting...
    07:16:43 fsync-ing the write ahead log in SyncThread:3 took 1224ms...
    07:16:46 fsync-ing the write ahead log in SyncThread:3 took 3205ms... // Snapshotting
    ...
    07:17:14 [FastLeaderElection@818] - New election...                   // Leader Election


* etcd Reliability

We test...

- Kill all members
- Kill majority of members
- Kill leader
- Network partition
- Network latency
- More...


* etcd Reliability

Intensive failure injection testing

- [[http://dash.etcd.io/dashboard/db/functional-tests][dash.etcd.io]]
- >12,000 failure injections per day
- >1.5M injected for etcd v3


* etcd Go 10 Tips


* #1 Use latest Go

* Throughput

.image img/etcd_go_throughput.svg _ 900

* Latency

.image img/etcd_go_latency.svg _ 900

* CPU

.image img/etcd_go_cpu.svg _ 900

* Memory

.image img/etcd_go_memory.svg _ 900



* #2 Check slice allocation

[[https://github.com/coreos/etcd/pull/5238][GH5238]]

    s.changes = make([]mvccpb.KeyValue, 0, 128)
    s.changes = make([]mvccpb.KeyValue, 0, 4)    // better for etcd use case

More capacity means more allocation.

Check your use case when making slice!


* Throughput

.image img/etcd_slice_optimization_throughput.svg _ 900


* Latency

.image img/etcd_slice_optimization_latency.svg _ 900



* #3 Test your code

All with "go test" command

- unit tests
- integration tests
- functional tests
- benchmarks

Use expect package for e2e tests

    proc, _ = expect.NewExpect("etcdctl", "get", "foo")
    _, err = proc.Expect("bar")  // if err != nil, found a bug!

[[https://godoc.org/github.com/coreos/etcd/pkg/expect][github.com/coreos/etcd/pkg/expect]]


* #4 Check goroutine leaks

Scan runtime.Stack

	func TestMain(m *testing.M) {
		v := m.Run()
		if v == 0 && testutil.CheckLeakedGoroutine() {
			os.Exit(1)
		}
		os.Exit(v)
	}

	func TestSample(t *testing.T) {
		defer testutil.AfterTest(t)
		...
	}


- [[https://github.com/golang/go/blob/master/src/net/http/main_test.go][net/http/main_test.go]]
- [[https://godoc.org/github.com/coreos/etcd/pkg/testutil][github.com/coreos/etcd/pkg/testutil]]

Highly recommend for projects with context.Context, gRPC


* #5 Always gofmt, go vet

gofmt
.image img/gofmt.png _ 400

go vet

	log.Fatalf("hello %d", "a")
	// arg "a" for printf verb %d of wrong type: string


* #6 Write simple Go

   ok := true
   if ok == true {}  // X
   if ok {}          // O

Don't:

    err := l.newStream()
    if err != nil {		
        return err		
    }		
    return nil		

Do:

    return l.newStream()

[[https://github.com/dominikh/go-simple][github.com/dominikh/go-simple]] by Dominik


* #7 Check unused

- [[https://github.com/dominikh/go-unused][github.com/dominikh/go-unused]] by Dominik
- Finds unused constants, variables, functions and types

    func reportMetrics() {}
    // func reportMetrics is unused

Found bugs in etcd [[https://github.com/coreos/etcd/pull/4995/files][GH4955]]


* #8 Use goword

- [[https://github.com/chzchzchz/goword][github.com/chzchzchz/goword]] by Anthony (etcd team)

Comment checker

    // This.
    func Hello() {}  // This. (godoc-export: This -> Hello?)"

Spell checker

    // Hello retuens.
    func Hello() {}  // Hello retuens. (spell: retuens -> returns?)


* #9 Document with godoc

- etcd must be easy to use
- etcd needs good documentation
- Example? [[https://github.com/coreos/etcd/tree/master/clientv3][etcd/clientv3]]


* #10 vendor

Problem

- etcd client package is used within etcd repo (etcdctl)
- etcd client imports gRPC and vendors it
- Project B import this etcd client package
- Project B also uses gRPC but from different import path


Now two projects has conflicting gRPC code [[https://github.com/grpc/grpc-go/issues/566][GH566]]

    panic: http: multiple registrations for /debug/requests


* #10 vendor

Solution [[https://github.com/coreos/etcd/pull/4950][GH4950]]

- Create symlinks inside cmd directory
- ln -s main.go cmd/main.go
- cmd/vendor

Update dependency

- ln -s cmd/vendor vendor
- godep save


Still go-get-able. No conflicts with other projects.

Works, even on Windows!
